//
// File generated by rootcint at Wed Nov 13 09:42:05 2013

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME FileIOCint
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "FileIOCint.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::bin_io_handler bin_io_handler;
      #else
      class bin_io_handler  :  public ::decoder_base {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::bin_io_handler::MODE MODE;
         #else
         enum MODE  {
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::bin_io_handler::STATUS STATUS;
         #else
         enum STATUS  {
         };
         #endif

         // To force the creation of a virtual table, throw just in case.
         virtual ~bin_io_handler() throw() {};
         string _filename; ///< Input/Output filename
         bool _eof; ///< EOF boolean
         unsigned short _nwords_in_file; ///< Number of words read or written per file
         unsigned int _checksum; ///< checksum of operated 32-bit words
         unsigned long _file_suffix; ///< A counter for file suffix in case output is too big.
         unsigned int _single_word[1]; ///< A place holder variable to process a single word
         unsigned int _word; ///< A word set to be read/write-out
         unsigned int _nchars; ///< Number of chars read in case of ASCII file
         ::FORMAT::INPUT_FILE _format; ///< Input file format
         STATUS _status; ///< Process status flag
         MODE _mode; ///< I/O mode
         FILE* _handler; ///< File handler pointer
         vector< PMT::word_t > _read_word_buffer; //
         unsigned long _multi_word_index; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::bin_word_search bin_word_search;
      #else
      class bin_word_search  :  public ::decoder_base {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::bin_word_search::WORD_BYTES WORD_BYTES;
         #else
         enum WORD_BYTES  {
         };
         #endif

         // To force the creation of a virtual table, throw just in case.
         virtual ~bin_word_search() throw() {};
         ::bin_io_handler _fin; //
         unsigned int _target; //
         bool _continue_mode; //
         unsigned long _nwords; //
         WORD_BYTES _bytes; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void bin_io_handler_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void bin_io_handler_Dictionary();
   static void *new_bin_io_handler(void *p = 0);
   static void *newArray_bin_io_handler(Long_t size, void *p);
   static void delete_bin_io_handler(void *p);
   static void deleteArray_bin_io_handler(void *p);
   static void destruct_bin_io_handler(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::bin_io_handler*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::bin_io_handler) == sizeof(::ROOT::Shadow::bin_io_handler));
      ::bin_io_handler *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::bin_io_handler),0);
      static ::ROOT::TGenericClassInfo 
         instance("bin_io_handler", "./bin_io_handler.hh", 26,
                  typeid(::bin_io_handler), DefineBehavior(ptr, ptr),
                  &bin_io_handler_ShowMembers, &bin_io_handler_Dictionary, isa_proxy, 4,
                  sizeof(::bin_io_handler) );
      instance.SetNew(&new_bin_io_handler);
      instance.SetNewArray(&newArray_bin_io_handler);
      instance.SetDelete(&delete_bin_io_handler);
      instance.SetDeleteArray(&deleteArray_bin_io_handler);
      instance.SetDestructor(&destruct_bin_io_handler);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::bin_io_handler*)
   {
      return GenerateInitInstanceLocal((::bin_io_handler*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::bin_io_handler*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void bin_io_handler_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::bin_io_handler*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void bin_word_search_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void bin_word_search_Dictionary();
   static void *new_bin_word_search(void *p = 0);
   static void *newArray_bin_word_search(Long_t size, void *p);
   static void delete_bin_word_search(void *p);
   static void deleteArray_bin_word_search(void *p);
   static void destruct_bin_word_search(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::bin_word_search*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::bin_word_search) == sizeof(::ROOT::Shadow::bin_word_search));
      ::bin_word_search *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::bin_word_search),0);
      static ::ROOT::TGenericClassInfo 
         instance("bin_word_search", "./bin_word_search.hh", 9,
                  typeid(::bin_word_search), DefineBehavior(ptr, ptr),
                  &bin_word_search_ShowMembers, &bin_word_search_Dictionary, isa_proxy, 4,
                  sizeof(::bin_word_search) );
      instance.SetNew(&new_bin_word_search);
      instance.SetNewArray(&newArray_bin_word_search);
      instance.SetDelete(&delete_bin_word_search);
      instance.SetDeleteArray(&deleteArray_bin_word_search);
      instance.SetDestructor(&destruct_bin_word_search);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::bin_word_search*)
   {
      return GenerateInitInstanceLocal((::bin_word_search*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::bin_word_search*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void bin_word_search_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::bin_word_search*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void bin_io_handler_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class bin_io_handler.
      typedef ::ROOT::Shadow::bin_io_handler ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::bin_io_handler*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_filename", (void*)&sobj->_filename);
      R__insp.InspectMember("string", (void*)&sobj->_filename, "_filename.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_eof", &sobj->_eof);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nwords_in_file", &sobj->_nwords_in_file);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_checksum", &sobj->_checksum);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_file_suffix", &sobj->_file_suffix);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_single_word[1]", sobj->_single_word);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_word", &sobj->_word);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nchars", &sobj->_nchars);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_format", &sobj->_format);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_status", &sobj->_status);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_mode", &sobj->_mode);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "*_handler", &sobj->_handler);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_read_word_buffer", (void*)&sobj->_read_word_buffer);
      R__insp.InspectMember("vector<PMT::word_t>", (void*)&sobj->_read_word_buffer, "_read_word_buffer.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_multi_word_index", &sobj->_multi_word_index);
      R__insp.GenericShowMembers("decoder_base", ( ::decoder_base * )( (::bin_io_handler*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_bin_io_handler(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::bin_io_handler : new ::bin_io_handler;
   }
   static void *newArray_bin_io_handler(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::bin_io_handler[nElements] : new ::bin_io_handler[nElements];
   }
   // Wrapper around operator delete
   static void delete_bin_io_handler(void *p) {
      delete ((::bin_io_handler*)p);
   }
   static void deleteArray_bin_io_handler(void *p) {
      delete [] ((::bin_io_handler*)p);
   }
   static void destruct_bin_io_handler(void *p) {
      typedef ::bin_io_handler current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::bin_io_handler

//______________________________________________________________________________
namespace ROOT {
   void bin_word_search_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class bin_word_search.
      typedef ::ROOT::Shadow::bin_word_search ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::bin_word_search*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_fin", (void*)&sobj->_fin);
      R__insp.InspectMember("bin_io_handler", (void*)&sobj->_fin, "_fin.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_target", &sobj->_target);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_continue_mode", &sobj->_continue_mode);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_nwords", &sobj->_nwords);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "_bytes", &sobj->_bytes);
      R__insp.GenericShowMembers("decoder_base", ( ::decoder_base * )( (::bin_word_search*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_bin_word_search(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::bin_word_search : new ::bin_word_search;
   }
   static void *newArray_bin_word_search(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::bin_word_search[nElements] : new ::bin_word_search[nElements];
   }
   // Wrapper around operator delete
   static void delete_bin_word_search(void *p) {
      delete ((::bin_word_search*)p);
   }
   static void deleteArray_bin_word_search(void *p) {
      delete [] ((::bin_word_search*)p);
   }
   static void destruct_bin_word_search(void *p) {
      typedef ::bin_word_search current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::bin_word_search

namespace ROOT {
   void vectorlEunsignedsPintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEunsignedsPintgR_Dictionary();
   static void *new_vectorlEunsignedsPintgR(void *p = 0);
   static void *newArray_vectorlEunsignedsPintgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPintgR(void *p);
   static void deleteArray_vectorlEunsignedsPintgR(void *p);
   static void destruct_vectorlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned int>*)
   {
      vector<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned int>", -2, "vector.dll", 0,
                  typeid(vector<unsigned int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned int>) );
      instance.SetNew(&new_vectorlEunsignedsPintgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPintgR);
      instance.SetDelete(&delete_vectorlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPintgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<unsigned int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int> : new vector<unsigned int>;
   }
   static void *newArray_vectorlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int>[nElements] : new vector<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPintgR(void *p) {
      delete ((vector<unsigned int>*)p);
   }
   static void deleteArray_vectorlEunsignedsPintgR(void *p) {
      delete [] ((vector<unsigned int>*)p);
   }
   static void destruct_vectorlEunsignedsPintgR(void *p) {
      typedef vector<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned int>

/********************************************************
* FileIOCint.cc
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableFileIOCint();

extern "C" void G__set_cpp_environmentFileIOCint() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("FileIO-TypeDef.hh");
  G__add_compiledheader("bin_io_handler.hh");
  G__add_compiledheader("bin_word_search.hh");
  G__cpp_reset_tagtableFileIOCint();
}
#include <new>
extern "C" int G__cpp_dllrevFileIOCint() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* bin_io_handler */
static int G__FileIOCint_226_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   bin_io_handler* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new bin_io_handler((FORMAT::INPUT_FILE) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) bin_io_handler((FORMAT::INPUT_FILE) G__int(libp->para[0]));
     }
     break;
   case 0:
     int n = G__getaryconstruct();
     if (n) {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new bin_io_handler[n];
       } else {
         p = new((void*) gvp) bin_io_handler[n];
       }
     } else {
       if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
         p = new bin_io_handler;
       } else {
         p = new((void*) gvp) bin_io_handler;
       }
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((bin_io_handler*) G__getstructoffset())->write_word((const PMT::word_t) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((bin_io_handler*) G__getstructoffset())->write_multi_word((const PMT::word_t*) G__int(libp->para[0]), (const size_t) G__int(libp->para[1])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 104, (long) ((bin_io_handler*) G__getstructoffset())->read_word());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_io_handler*) G__getstructoffset())->set_format((FORMAT::INPUT_FILE) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_io_handler*) G__getstructoffset())->set_mode((bin_io_handler::MODE) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_io_handler*) G__getstructoffset())->set_filename(*((string*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const bin_io_handler*) G__getstructoffset())->eof());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((bin_io_handler*) G__getstructoffset())->open());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const bin_io_handler*) G__getstructoffset())->is_open());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_io_handler*) G__getstructoffset())->close();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_io_handler*) G__getstructoffset())->reset();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_226_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 104, (long) ((bin_io_handler*) G__getstructoffset())->read_multi_word((size_t) G__int(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 104, (long) ((bin_io_handler*) G__getstructoffset())->read_multi_word());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__FileIOCint_226_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   bin_io_handler* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new bin_io_handler(*(bin_io_handler*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef bin_io_handler G__Tbin_io_handler;
static int G__FileIOCint_226_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (bin_io_handler*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((bin_io_handler*) (soff+(sizeof(bin_io_handler)*i)))->~G__Tbin_io_handler();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (bin_io_handler*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((bin_io_handler*) (soff))->~G__Tbin_io_handler();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__FileIOCint_226_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   bin_io_handler* dest = (bin_io_handler*) G__getstructoffset();
   *dest = *(bin_io_handler*) libp->para[0].ref;
   const bin_io_handler& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* bin_word_search */
static int G__FileIOCint_229_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   bin_word_search* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new bin_word_search[n];
     } else {
       p = new((void*) gvp) bin_word_search[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new bin_word_search;
     } else {
       p = new((void*) gvp) bin_word_search;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_word_search*) G__getstructoffset())->set_target_word((PMT::word_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_word_search*) G__getstructoffset())->set_filename(*((string*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_word_search*) G__getstructoffset())->set_continue_mode((bool) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_word_search*) G__getstructoffset())->set_format((FORMAT::INPUT_FILE) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_word_search*) G__getstructoffset())->set_nwords((size_t) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_word_search*) G__getstructoffset())->set_word_bytes((bin_word_search::WORD_BYTES) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((bin_word_search*) G__getstructoffset())->run());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__FileIOCint_229_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((bin_word_search*) G__getstructoffset())->print_words((deque<PMT::word_t>*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__FileIOCint_229_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   bin_word_search* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new bin_word_search(*(bin_word_search*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef bin_word_search G__Tbin_word_search;
static int G__FileIOCint_229_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (bin_word_search*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((bin_word_search*) (soff+(sizeof(bin_word_search)*i)))->~G__Tbin_word_search();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (bin_word_search*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((bin_word_search*) (soff))->~G__Tbin_word_search();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__FileIOCint_229_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   bin_word_search* dest = (bin_word_search*) G__getstructoffset();
   *dest = *(bin_word_search*) libp->para[0].ref;
   const bin_word_search& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* bin_io_handler */

/* bin_word_search */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncFileIOCint {
 public:
  G__Sizep2memfuncFileIOCint(): p(&G__Sizep2memfuncFileIOCint::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncFileIOCint::*p)();
};

size_t G__get_sizep2memfuncFileIOCint()
{
  G__Sizep2memfuncFileIOCint a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceFileIOCint() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler))) {
     bin_io_handler *G__Lderived;
     G__Lderived=(bin_io_handler*)0x1000;
     {
       decoder_base *G__Lpbase=(decoder_base*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler),G__get_linked_tagnum(&G__FileIOCintLN_decoder_base),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search))) {
     bin_word_search *G__Lderived;
     G__Lderived=(bin_word_search*)0x1000;
     {
       decoder_base *G__Lpbase=(decoder_base*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search),G__get_linked_tagnum(&G__FileIOCintLN_decoder_base),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableFileIOCint() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__FileIOCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__FileIOCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__FileIOCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__FileIOCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__FileIOCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__FileIOCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__FileIOCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__FileIOCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__FileIOCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__FileIOCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<std::bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,std::ptrdiff_t,const TObject**,const TObject*&>",117,G__get_linked_tagnum(&G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*>",117,G__get_linked_tagnum(&G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long>",117,G__get_linked_tagnum(&G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("iterator<bidirectional_iterator_tag,TObject*,long,const TObject**>",117,G__get_linked_tagnum(&G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<PMT::word_t>",117,G__get_linked_tagnum(&G__FileIOCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("deque<PMT::word_t>",117,G__get_linked_tagnum(&G__FileIOCintLN_dequelEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("deque<unsigned int>",117,G__get_linked_tagnum(&G__FileIOCintLN_dequelEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* bin_io_handler */
static void G__setup_memvarbin_io_handler(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler));
   { bin_io_handler *p; p=(bin_io_handler*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLMODE),-1,-2,1,G__FastAllocString(2048).Format("READ=%lldLL",(long long)bin_io_handler::READ).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLMODE),-1,-2,1,G__FastAllocString(2048).Format("WRITE=%lldLL",(long long)bin_io_handler::WRITE).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLSTATUS),-1,-2,1,G__FastAllocString(2048).Format("INIT=%lldLL",(long long)bin_io_handler::INIT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLSTATUS),-1,-2,1,G__FastAllocString(2048).Format("OPENED=%lldLL",(long long)bin_io_handler::OPENED).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLSTATUS),-1,-2,1,G__FastAllocString(2048).Format("OPERATING=%lldLL",(long long)bin_io_handler::OPERATING).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLSTATUS),-1,-2,1,G__FastAllocString(2048).Format("CLOSED=%lldLL",(long long)bin_io_handler::CLOSED).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__FileIOCintLN_string),-1,-1,4,"_filename=",0,"/< Input/Output filename");
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"_eof=",0,"/< EOF boolean");
   G__memvar_setup((void*)0,114,0,0,-1,G__defined_typename("UShort_t"),-1,4,"_nwords_in_file=",0,"/< Number of words read or written per file");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("UInt_t"),-1,4,"_checksum=",0,"/< checksum of operated 32-bit words");
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"_file_suffix=",0,"/< A counter for file suffix in case output is too big.");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("word_t"),-1,4,"_single_word[1]=",0,"/< A place holder variable to process a single word");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("word_t"),-1,4,"_word=",0,"/< A word set to be read/write-out");
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("word_t"),-1,4,"_nchars=",0,"/< Number of chars read in case of ASCII file");
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__FileIOCintLN_FORMATcLcLINPUT_FILE),-1,-1,4,"_format=",0,"/< Input file format");
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLSTATUS),-1,-1,4,"_status=",0,"/< Process status flag");
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handlercLcLMODE),-1,-1,4,"_mode=",0,"/< I/O mode");
   G__memvar_setup((void*)0,69,0,0,-1,-1,-1,4,"_handler=",0,"/< File handler pointer");
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__FileIOCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),G__defined_typename("vector<PMT::word_t>"),-1,4,"_read_word_buffer=",0,(char*)NULL);
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"_multi_word_index=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* bin_word_search */
static void G__setup_memvarbin_word_search(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search));
   { bin_word_search *p; p=(bin_word_search*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_word_searchcLcLWORD_BYTES),-1,-2,1,G__FastAllocString(2048).Format("INT=%lldLL",(long long)bin_word_search::INT).data(),0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__FileIOCintLN_bin_word_searchcLcLWORD_BYTES),-1,-2,1,G__FastAllocString(2048).Format("SHORT=%lldLL",(long long)bin_word_search::SHORT).data(),0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler),-1,-1,4,"_fin=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,G__defined_typename("word_t"),-1,4,"_target=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"_continue_mode=",0,(char*)NULL);
   G__memvar_setup((void*)0,107,0,0,-1,G__defined_typename("size_t"),-1,4,"_nwords=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,G__get_linked_tagnum(&G__FileIOCintLN_bin_word_searchcLcLWORD_BYTES),-1,-1,4,"_bytes=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarFileIOCint() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncbin_io_handler(void) {
   /* bin_io_handler */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler));
   G__memfunc_setup("bin_io_handler",1453,G__FileIOCint_226_0_1, 105, G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler), -1, 0, 1, 1, 1, 0, "i 'FORMAT::INPUT_FILE' - 0 'FORMAT::UNDEFINED' type", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("write_word",1094,G__FileIOCint_226_0_2, 103, -1, -1, 0, 1, 1, 1, 0, "h - 'PMT::word_t' 10 - word", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("write_multi_word",1744,G__FileIOCint_226_0_3, 103, -1, -1, 0, 2, 1, 1, 0, 
"H - 'PMT::word_t' 10 - words k - 'size_t' 10 - entries", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("read_word",951,G__FileIOCint_226_0_4, 104, -1, G__defined_typename("PMT::word_t"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_format",1076,G__FileIOCint_226_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "i 'FORMAT::INPUT_FILE' - 0 - f", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_mode",848,G__FileIOCint_226_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "i 'bin_io_handler::MODE' - 0 - mode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_filename",1260,G__FileIOCint_226_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 0 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("eof",314,G__FileIOCint_226_0_8, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("open",434,G__FileIOCint_226_0_9, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("is_open",749,G__FileIOCint_226_0_10, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("close",534,G__FileIOCint_226_0_11, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reset",547,G__FileIOCint_226_0_12, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("read_multi_word",1601,G__FileIOCint_226_0_13, 104, -1, G__defined_typename("PMT::word_t"), 0, 1, 1, 1, 0, "k - 'size_t' 0 '0' length", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("bin_io_handler", 1453, G__FileIOCint_226_0_14, (int) ('i'), G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler), -1, 0, 1, 1, 1, 0, "u 'bin_io_handler' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~bin_io_handler", 1579, G__FileIOCint_226_0_15, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__FileIOCint_226_0_16, (int) ('u'), G__get_linked_tagnum(&G__FileIOCintLN_bin_io_handler), -1, 1, 1, 1, 1, 0, "u 'bin_io_handler' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncbin_word_search(void) {
   /* bin_word_search */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search));
   G__memfunc_setup("bin_word_search",1577,G__FileIOCint_229_0_1, 105, G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_target_word",1613,G__FileIOCint_229_0_2, 121, -1, -1, 0, 1, 1, 1, 0, "h - 'PMT::word_t' 0 - word", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_filename",1260,G__FileIOCint_229_0_3, 121, -1, -1, 0, 1, 1, 1, 0, "u 'string' - 0 - name", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_continue_mode",1812,G__FileIOCint_229_0_4, 121, -1, -1, 0, 1, 1, 1, 0, "g - - 0 - mode", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_format",1076,G__FileIOCint_229_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "i 'FORMAT::INPUT_FILE' - 0 - fmt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_nwords",1096,G__FileIOCint_229_0_6, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'size_t' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set_word_bytes",1517,G__FileIOCint_229_0_7, 121, -1, -1, 0, 1, 1, 1, 0, "i 'bin_word_search::WORD_BYTES' - 0 - bytes", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("run",341,G__FileIOCint_229_0_8, 103, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("print_words",1211,G__FileIOCint_229_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "U 'deque<unsigned int,allocator<unsigned int> >' 'deque<PMT::word_t>' 0 - words", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("bin_word_search", 1577, G__FileIOCint_229_0_10, (int) ('i'), G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search), -1, 0, 1, 1, 1, 0, "u 'bin_word_search' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~bin_word_search", 1703, G__FileIOCint_229_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__FileIOCint_229_0_12, (int) ('u'), G__get_linked_tagnum(&G__FileIOCintLN_bin_word_search), -1, 1, 1, 1, 1, 0, "u 'bin_word_search' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncFileIOCint() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {
}

static void G__cpp_setup_global2() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalFileIOCint() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
  G__cpp_setup_global2();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcFileIOCint() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__FileIOCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR = { "iterator<bidirectional_iterator_tag,TObject*,long,const TObject**,const TObject*&>" , 115 , -1 };
G__linked_taginfo G__FileIOCintLN_FORMAT = { "FORMAT" , 110 , -1 };
G__linked_taginfo G__FileIOCintLN_FORMATcLcLINPUT_FILE = { "FORMAT::INPUT_FILE" , 101 , -1 };
G__linked_taginfo G__FileIOCintLN_decoder_base = { "decoder_base" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_bin_io_handler = { "bin_io_handler" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_bin_io_handlercLcLMODE = { "bin_io_handler::MODE" , 101 , -1 };
G__linked_taginfo G__FileIOCintLN_bin_io_handlercLcLSTATUS = { "bin_io_handler::STATUS" , 101 , -1 };
G__linked_taginfo G__FileIOCintLN_bin_word_search = { "bin_word_search" , 99 , -1 };
G__linked_taginfo G__FileIOCintLN_bin_word_searchcLcLWORD_BYTES = { "bin_word_search::WORD_BYTES" , 101 , -1 };
G__linked_taginfo G__FileIOCintLN_dequelEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "deque<unsigned int,allocator<unsigned int> >" , 99 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableFileIOCint() {
  G__FileIOCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__FileIOCintLN_string.tagnum = -1 ;
  G__FileIOCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__FileIOCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__FileIOCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__FileIOCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR.tagnum = -1 ;
  G__FileIOCintLN_FORMAT.tagnum = -1 ;
  G__FileIOCintLN_FORMATcLcLINPUT_FILE.tagnum = -1 ;
  G__FileIOCintLN_decoder_base.tagnum = -1 ;
  G__FileIOCintLN_bin_io_handler.tagnum = -1 ;
  G__FileIOCintLN_bin_io_handlercLcLMODE.tagnum = -1 ;
  G__FileIOCintLN_bin_io_handlercLcLSTATUS.tagnum = -1 ;
  G__FileIOCintLN_bin_word_search.tagnum = -1 ;
  G__FileIOCintLN_bin_word_searchcLcLWORD_BYTES.tagnum = -1 ;
  G__FileIOCintLN_dequelEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableFileIOCint() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_string);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_iteratorlEbidirectional_iterator_tagcOTObjectmUcOlongcOconstsPTObjectmUmUcOconstsPTObjectmUaNgR);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_FORMAT);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_FORMATcLcLINPUT_FILE);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_decoder_base);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__FileIOCintLN_bin_io_handler),sizeof(bin_io_handler),-1,263424,(char*)NULL,G__setup_memvarbin_io_handler,G__setup_memfuncbin_io_handler);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_bin_io_handlercLcLMODE);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_bin_io_handlercLcLSTATUS);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__FileIOCintLN_bin_word_search),sizeof(bin_word_search),-1,263424,(char*)NULL,G__setup_memvarbin_word_search,G__setup_memfuncbin_word_search);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_bin_word_searchcLcLWORD_BYTES);
   G__get_linked_tagnum_fwd(&G__FileIOCintLN_dequelEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
}
extern "C" void G__cpp_setupFileIOCint(void) {
  G__check_setup_version(30051515,"G__cpp_setupFileIOCint()");
  G__set_cpp_environmentFileIOCint();
  G__cpp_setup_tagtableFileIOCint();

  G__cpp_setup_inheritanceFileIOCint();

  G__cpp_setup_typetableFileIOCint();

  G__cpp_setup_memvarFileIOCint();

  G__cpp_setup_memfuncFileIOCint();
  G__cpp_setup_globalFileIOCint();
  G__cpp_setup_funcFileIOCint();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncFileIOCint();
  return;
}
class G__cpp_setup_initFileIOCint {
  public:
    G__cpp_setup_initFileIOCint() { G__add_setup_func("FileIOCint",(G__incsetup)(&G__cpp_setupFileIOCint)); G__call_setup_funcs(); }
   ~G__cpp_setup_initFileIOCint() { G__remove_setup_func("FileIOCint"); }
};
G__cpp_setup_initFileIOCint G__cpp_setup_initializerFileIOCint;

