/************************************************************************
*  File: pcie_diag.c
*
*  Sample user-mode diagnostics application for accessing PCIE
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.21.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/

#include "wd_utils.c"
#include "nevis_pcie_utils.c"

static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2);
static void MenuMBtest(WDC_DEVICE_HANDLE hDev,WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2);

/*************************************************************
  Functions implementation
 *************************************************************/
int main(void)
{

  struct timeval start;
  gettimeofday(&start,NULL);

  long seconds, useconds;
  seconds = start.tv_sec;
  useconds = start.tv_usec;
      
  printf("\nStart time of program: %ld sec %ld usec\n",seconds,useconds);


    WDC_DEVICE_HANDLE hDev = NULL;
    WDC_DEVICE_HANDLE hDev1 = NULL;
    WDC_DEVICE_HANDLE hDev2 = NULL;

    DWORD dwStatus;

    printf("\n");
    printf("PCIE diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME ".\n");

    /* Initialize the PCIE library */
    dwStatus = PCIE_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        PCIE_ERR("pcie_diag: Failed to initialize the PCIE library: %s",
            PCIE_GetLastErr());
        return dwStatus;
    }

    /* Find and open a PCIE device (by default ID) */
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev1 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+1);
    if (PCIE_DEFAULT_VENDOR_ID)
        hDev2 = DeviceFindAndOpen(PCIE_DEFAULT_VENDOR_ID, PCIE_DEFAULT_DEVICE_ID+2);

    /* Display main diagnostics menu for communicating with the device */
    MenuMain(&hDev, &hDev1, &hDev2);

    /* Perform necessary cleanup before exiting the program */
    if (hDev)
        DeviceClose(hDev);
        DeviceClose(hDev1);
        DeviceClose(hDev2);

    dwStatus = PCIE_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
        PCIE_ERR("pcie_diag: Failed to uninit the PCIE library: %s", PCIE_GetLastErr());
    
    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
/* Main menu options */
enum {
    MENU_MAIN_SCAN_PCI_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_EVENTS,
    MENU_MAIN_MB_TEST, /* add new route for testing */
    MENU_MAIN_JSEBII_TEST, /* add new route for testing */
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE *phDev, WDC_DEVICE_HANDLE *phDev1, WDC_DEVICE_HANDLE *phDev2)
{
    DWORD option;
    
    do
    {
        printf("\n");
        printf("PCIE main menu\n");
        printf("--------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_PCI_BUS);
        printf("%d. Find and open a PCIE device\n", MENU_MAIN_FIND_AND_OPEN);
        if (*phDev)
        {
            printf("%d. Read/write memory and IO addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Read/write the device's configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            if (PCIE_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
            printf("%d. MicroBoone test\n", MENU_MAIN_MB_TEST);
            printf("%d. Test loop for PCIe\n", MENU_MAIN_JSEBII_TEST);
        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);

	/**        
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_EVENTS : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }
	**/

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_JSEBII_TEST : MENU_MAIN_FIND_AND_OPEN))
        {
            continue;
        }

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_PCI_BUS: /* Scan PCI bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a PCIE device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/Write the PCIE configuration space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (PCIE_REGS_NUM)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;
        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power management events */
            MenuEvents(*phDev);
            break;
        case MENU_MAIN_MB_TEST: /* my test loop DMA */
            MenuMBtest(*phDev, *phDev1, *phDev2);
            break;
        case MENU_MAIN_JSEBII_TEST: /* my test loop DMA */
	  //Menujsebii_test(*phDev);
	  break;
        }
    } while (MENU_MAIN_EXIT != option);
}


/* Read/write memory or I/O space address menu */
static void MenuMBtest(WDC_DEVICE_HANDLE hDev, WDC_DEVICE_HANDLE hDev1 ,WDC_DEVICE_HANDLE hDev2)
{

#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25
#define  mb_xmit_link_pll_reset    26

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        40000000

    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
    static unsigned long long u64Data, u64Data1;
    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[dma_buffer_size],read_array1[40000];
    static UINT32 read_array_c[40000];
    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
    unsigned short idcm_read_array[40000],read_array_s[1600000];
    static UINT32 idcm_read_array32[40000];
    static UINT32 idcm_send_array[400000];
    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff,sample_b,dis;
    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
    PVOID pbuf;
    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,iframe,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint, nwrite_byte,idis_c,idis_c1;
    static int   icomp_index, nword_comp, nk, ilast_check;
    static int   ic_ev, ic_fr, event_save, frame_save,frame_ev,event_ev;
    static int   imod_fem, imod_st, imod_last, itrig_type, last_dma_loop_size;
    static int   fd, n_read, n_write, pt_trig_wdone, pt_snova_wdone;
    static int   pt_trig_dmastart;
    static int   nremain, nread_dma,nremain_tran1, nremain_tran2,ig, nremain_dma;
    static int   rc_pt, nword_n, nwrite_byte_n, is1;
    static int   wait_min, wait_max;
    static int   iwait_usec,iwait_loop;
    static int   icom_factor,ifr_c2, ith_fr;
    static int   pmt_dac_scan,idac_shaper;
    static int   itrig_pulse,p1_delay,p1_width,p2_delay,p2_width, pulse_trig_delay;
    static int   icont,ibytec,n_trig, imulti;
    void *status_pt;
    size_t stacksize;
//
//
    pthread_t threads[3];
    pthread_attr_t attr_pt_trig_dma, attr_pt_sn_dma;
    pthread_attr_t attr_pt_tr, attr_pt_sn;

//
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    PVOID pbuf_rec1;
    WD_DMA *pDma_rec1;
    PVOID pbuf_rec2;
    WD_DMA *pDma_rec2;

//    PVOID pbuf_rec_n;
//    WD_DMA *pDma_rec_n;

    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;

    static UINT64 *buffp_rec64;
    static UINT32 *buffp_rec32, *buffp_rec32_n;
    UINT32 *px, *py, *py1;

    FILE *outf,*inpf;
    
    struct thread_data
    {
      int id;
      WDC_DEVICE_HANDLE hdev;
      WDC_DEVICE_HANDLE hdevc;
    };

    struct thread_data thread_data_n;
    struct thread_data thread_data_sn;




    nread = 4096*2+6; /*16384 32768, 65536+4;  number of byte to be readout */
    ifr=0;
    iwrite =0;
    iprint =0;
    icheck =0;
    istop=0;

    dwDMABufSize = 1000000;

    printf(" MicroBoone PMT link test routine \n");
    //     printf(" enter time size \n");
    //     scanf("%d",&timesize);
    printf(" number of event\n");
    scanf("%d",&nevent);
    ihuff =0;  // no huffman encoding -- need to predict event size
    //
    //
    printf(" type 1 to use trigger module \n");
    scanf("%d", &itrig_ext);
    if(itrig_ext == 1) {
      printf(" type 1 to use trigger module as pulser \n");
      scanf("%d", &itrig_pulse);
      if (itrig_pulse == 1) {
	printf(" enter pulse 1 delay \n");
	scanf("%d", &p1_delay);
	printf(" enter pulse 1 width \n");
	scanf("%d", &p1_width);
	printf(" enter pulse 2 delay \n");
	scanf("%d", &p2_delay);
	printf(" enter pulse 2 width \n");
	scanf("%d", &p2_width);
	printf(" enter trigger delay (<7)\n");
	scanf("%d", &pulse_trig_delay);
      }
    }
    
    printf(" type 1 to set up PMT ADC \n");
    scanf("%d", &use_pmt);
    if(use_pmt == 1) {
      printf(" type 1 to fire test pulse  \n");
      scanf("%d", &pmt_testpulse);
      if(pmt_testpulse ==1 ) {
	printf(" type 1 to step through DAC \n");
	scanf("%d", &pmt_dac_scan);
	if(pmt_dac_scan != 1) {
	  printf(" enter DAC value \n");
	  scanf("%d",&idac_shaper);
	}
      }
      else idac_shaper = 2047;
    }
    int ibin=0;
    printf(" type 1 for continous running \n");
    scanf("%d",&icont);
    if(icont == 1) {
      printf(" enter 1 for bin file output\n");
      scanf("%d",&ibin);
      printf(" enter the byte count \n");
      scanf("%d", &ibytec);
      char _buf[200];
      if(ibin){
	sprintf(_buf,"/home/ub/xmit_newheader_%03d_%03d.bin",p1_delay,p2_delay);
	outf=fopen(_buf,"wb");
      }else{
	sprintf(_buf,"/home/ub/xmit_newheader_%03d_%03d.txt",p1_delay,p2_delay);
	outf=fopen(_buf,"w");
      }
    }
    
    /*
      if(icont == 1) {
      printf(" enter the byte count \n");
      scanf("%d", &ibytec);
      }
      printf("type 1 for multiple trigger \n");
      scanf("%d", &imulti);
      if(imulti == 1) {
      printf("enter number trigger per event \n");
      scanf("%d", &n_trig);
      }
    */
    idebug == 1;
    iwrite == 0;
    irawprint == 1;
    dwDMABufSize ==100000;
    //     printf("type 1 for print out debug information in dma loop\n");
    //     scanf("%d",&idebug);
    //     printf(" type 1 to write data to fiile \n");
    //     scanf("%d", &iwrite);
    //     printf("type 1 for raw data print \n");
    //     scanf("%d",&irawprint);
    //     printf(" enter buffer size in bytes \n");
    //     scanf("%d",&dwDMABufSize);
    //     printf(" enter 1 to check last word \n");
    //     scanf("%d",&ilast_check);
    //     printf(" enter 1 for wait loop \n");
    //     scanf("%d",&iwait_loop);
    //     if(iwait_loop == 1) {
    //       printf(" enter wait time in microsec unit \n");
    //       scanf("%d",&iwait_usec);
    //     }
    printf(" xmit module address \n");
    scanf("%d",&imod_xmit);
    printf(" slot address of the 1st FEM module \n");
    scanf("%d",&imod_st);
    printf(" number of FEM = %d\n",(imod_st - imod_xmit));
    //     printf(" type 1 for neutrino event, 2 for superNova \n");
    //     scanf("%d",&itrig_type);
    //
    //
    //
    imod_trig = 16;
    imod_shaper =6;
    itrig_delay = 51;
    //     imod_fem = 11;
    printf(" PMT ADC module address = %d \n", imod_fem);
    printf(" Shaper address = %d \n", imod_shaper);
    printf(" Trigger module address = %d \n", imod_trig);
    
    if(iwrite == 1) {
      fd = creat("test123.dat",0755);
      printf("fd = %d \n", fd);
    }
    iframe_length = 8191;
    iframe = iframe_length;
    //     iframe_length = 25599;
    itrig_delay = 10;
    //     timesize =2000;
    //     timesize =200;
    //     dwDMABufSize = 1500000;
    printf(" frame size = %d\n", iframe_length);
    //     timesize = 3199;
    
    //     printf(" 1 for checking the event \n");
    //     scanf("%d",&icheck);
    //     printf(" type 1 to use random number \n");
    //     scanf("%d",&irand);
    icheck =0;
    ifr=0;
    irand = 0;
    islow_read =0;
    //     if(icheck != 1) {
    //      printf(" 1 for print event\n");
    //      scanf("%d",&iprint);
    //    }
    //     else iprint =0;
    iprint = 1;
    //     printf(" number event \n");
    //     scanf("%d",&nevent);
    
    //     printf(" enter number of words per packet \n");
    //     scanf("%d",&nsend);
    nsend=500;
    //     imod_xmit=10;
    
    // once the fpga is booted we should let system receive fill frame before send any data.
    // set system with normal transmitter mode
    
    dwAddrSpace =2;
    u32Data = 0x20000000;    // initial transmitter, no hold
    dwOffset = 0x18;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x20000000;    // initial transmitter, no hold
    dwOffset = 0x20;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    
    dwAddrSpace =2;
    u32Data = 0x20000000;    // initial receiver
    dwOffset = 0x1c;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x20000000;   // initial receiver
    dwOffset = 0x24;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    
    
    dwAddrSpace =2;
    u32Data = 0xfff;    // set mode off with 0xfff...
    dwOffset = 0x28;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    
    //
    //
    //
    px = &buf_send;
    py = &read_array;
    imod =0;  /* controller module */
    /** initialize **/
    buf_send[0]=0x0;
    buf_send[1]=0x0;
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    // set offline test
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_on)+(0x0<<16); //enable offline run on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //disable the run command
    imod=0;
    ichip=1;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //trun off run
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //
    //
    //
    if(itrig_ext == 1) {
      //
      //  set trigger module run off
      //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_run)+((0x0)<<16); //set up run off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      //
      //  set trigger module dead time size
      //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_deadtime_size)+(0x1<<16); //set trigger module deadtime size
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      // set offline test
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_test_off)+(0x0<<16); //set controller test off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      
    }
    else {
      //
      //disable the run command
      //
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_off)+(0x0<<16); //enable offline run on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      //
      // load trig 1 position relative to the frame..
      //
      imod=0;
      ichip=1;
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_trig_pos)+((itrig_delay & 0xffff)<<16); //enable test mode
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
    }
    
    
    //     printf(" enable number of loop\n");
    //     scanf("%d",&nloop);
    //
    //   starting boot process
    //
    //
    //    boot up xmit module 1st
    //
    printf(" boot xmit module \n");
    inpf = fopen("/home/ub/xmit_fpga_link_header","r");
    imod=imod_xmit;
    ichip=mb_xmit_conf_add;
    buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    //      for (i=0; i<100000; i++) {
    //          ik= i%2;
    //          dummy1= (ik+i)*(ik+i);
    //      }
    
    
    /* read data as characters (28941) */
    usleep(1000);   // wait fior a while
    count = 0;
    counta= 0;
    ichip_c = 7; // set ichip_c to stay away from any other command in the
    dummy1 =0;
    while (fread(&charchannel,sizeof(char),1,inpf)==1) {
      carray[count] = charchannel;
      count++;
      counta++;
      if((count%(nsend*2)) == 0) {
	//        printf(" loop = %d\n",dummy1);
	buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
	send_array[0] =buf_send[0];
	if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
				,carray[2], carray[3]);
	for (ij=0; ij< nsend; ij++) {
	  if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
	  else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	  //         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
	  send_array[ij+1] = buf_send[ij+1];
	}
	nword =nsend+1;
	i=1;
	//       if(dummy1 == 0)
	ij = pcie_send(hDev, i, nword, px);
	nanosleep(&tim , &tim2);
	dummy1 = dummy1+1;
	count =0;
      }
    }
    if(feof(inpf)) {
      printf("You have reached the end-of-file word count= %d %d\n", counta, count);
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      if ( count > 1) {
	if( ((count-1)%2) ==0) {
	  ik =(count-1)/2;
	}
	else {
	  ik =(count-1)/2+1;
	}
	ik=ik+2;   // add one more for safety
	printf("ik= %d\n",ik);
	for (ij=0; ij<ik; ij++){
	  if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
	  else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
	  send_array[ij+1] = buf_send[ij+1];
	}
      }
      else ik=1;
      for (ij=ik-10; ij< ik+1; ij++) {
        printf("Last data = %d, %x\n",ij,buf_send[ij]);
      }
      nword =ik+1;
      i=1;
      i = pcie_send(hDev, i, nword, px);
    }
    usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
    fclose(inpf);
    //
    printf(" xmit done, booting FEM \n");
    scanf("%d",&ik);
    
    //
    //   *********************************************************************************
    //
    
    imod_last = imod_xmit+1;
    for (imod_fem = imod_last; imod_fem< (imod_st+1); imod_fem++) {
      printf(" booting FEM module %d \n",imod_fem);
      scanf("%d",&ik);
      ik=pmt_adc_setup(hDev,imod_fem,iframe);
    }
    
    //
    //    both FEM and XMIT bootted.
    //
    //
    //   /* set tx mode register */
    //
    u32Data = 0x00003fff;  // set up number of words hold coming back from the XMIT module
    printf(" number of words for hold be send back = %x\n",u32Data);
    dwOffset = 0x28;
    dwAddrSpace =2;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    //
    //   set up hold
    //
    printf(" set up the hold condition \n");
    dwAddrSpace =2;
    u32Data = 0x8000000;    // set up transmitter to return the hold -- upper transciever
    dwOffset = 0x18;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    dwAddrSpace =2;
    u32Data = 0x8000000;    // set up transmitter to return the hold -- lower transciever
    dwOffset = 0x20;
    WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
    //
    //
    if(itrig_ext == 1) {
      imod=imod_trig;
      //      iframe= 511;    //1023
      buf_send[0]=(imod<<11)+(mb_trig_frame_size)+((iframe & 0xffff)<<16); //set up frame size.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
    }
    else {
      //
      // set frame set to be 1023 --- there will be 1023/8 = 128 adc samples.
      //
      imod=0;
      ichip=1;
      //      iframe= 511;    //1024
      buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_load_frame)+((iframe & 0xffff)<<16); // set frame length
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
     }
    //
    //
    //
    if(itrig_ext == 1) {
      //
      //    set mask1 bit 3 high
      //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_mask1)+(0x8<<16); //set mask1[3] on.
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      //
      //    set prescale1 to 0
      //
      imod=imod_trig;
      buf_send[0]=(imod<<11)+(mb_trig_prescale1)+(0x0<<16); //set prescale1 0
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
    }
    
    //
    if(use_pmt ==1) {
      if(pmt_testpulse == 1) {
	//
	//     set dac value and write
	//
        imod =imod_shaper;  /* set shaper module DAC value */
        buf_send[0]=(imod<<11)+mb_shaper_dac+((0xfff & idac_shaper)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(10);
        imod =imod_shaper;  /* write to the DAC */
        buf_send[0]=(imod<<11)+mb_shaper_write+((0xfff)<<16);
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
	//
	//     set up pulse time
	//
        imod =imod_shaper;  /* write pulse time */
        idiv =1;
        isample =1;
        buf_send[0]=(imod<<11)+mb_shaper_pulsetime+(((idiv&0x7)+((isample&0xfff)<<3))<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
	//
	//      set firing patterm
	//

        imod =imod_shaper;  /* write to test pattern register */
        buf_send[0]=(imod<<11)+mb_shaper_pattern+((0xf)<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
      }
      //
      //     set up enable trigger or not
      //
      if(pmt_testpulse == 1) {
        imod =imod_shaper;
        if(itrig_ext == 1) is = 0;
        else is = 1;
        buf_send[0]=(imod<<11)+mb_shaper_entrig+((is)<<16);  // all bits on
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        usleep(1000);
      }
      
    }
    //
    //     enable PMT test mode
    //
    else {
      imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test+(0x1<<16);  // set PMT test data on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
    }
    //
    //
    //  ****************************************
    //
    printf(" call pmt_link \n");
    ik = pmt_link_setup(hDev,imod_xmit,imod_st,0);      // no supernova
    //
    //      turn the run on to start data flow
    //
    printf(" enter 1 to set the RUN on \n");
    scanf("%d",&ik);
    //
    //
    ifr=0;
    //
    for (ib=0; ib<nevent; ib++) {
      //
      //
      //
      if(use_pmt ==1) {
        if((pmt_testpulse == 1) & (pmt_dac_scan ==1)) {
	  if(idac_shaper == 4096) idac_shaper = 256;
	  else idac_shaper = idac_shaper+256;
	  //
	  //     set dac value and write
	  //
	  imod =imod_shaper;  /* set shaper module DAC value */
	  buf_send[0]=(imod<<11)+mb_shaper_dac+((0xfff & (idac_shaper-1))<<16);
	  i=1;
	  k=1;
	  i = pcie_send(hDev, i, k, px);
	  usleep(10);
	  imod =imod_shaper;  /* write to the DAC */
	  buf_send[0]=(imod<<11)+mb_shaper_write+((0xfff)<<16);
	  i=1;
	  k=1;
	  i = pcie_send(hDev, i, k, px);
	  usleep(1000);
        }
      }
      
      //
      //     set up test pulse
      //
      if(use_pmt != 1) {
	//
	//     clear PMT test FIFO
	//
        printf(" enter 1 to continue on sending clear\n");
        scanf("%d",&ik);
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_clear+(0x1<<16);  // clear PMT test data FIFO
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
	//
	//     load PMT test data
	//
        imod=imod_fem;
        ichip=3;
        irise=100;
        ifall=1;
        ibase =0;
        istart_time = 50;
        for (i=0; i< 256; i++) {
	  //        printf(" enter 1 to continue, loop %d, t_upper \n", i);
	  //        scanf("%d",&ik);
         is = ((istart_time<<12) & 0xfff) + 0x8000;
         ijk=1;
         k=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(is<<16);  // load PMT test data
         ijk = pcie_send(hDev, ijk, k, px);
	 //        printf(" enter 1 to continue, loop %d, t_lower \n", i);
	 //        scanf("%d",&ik);
         is = (istart_time & 0xfff) + 0x8000;
         ijk=1;
         k=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(is<<16);  // load PMT test data
         istart_time = istart_time+1;
         ijk = pcie_send(hDev, ijk, k, px);
	 //        printf(" istart_time %d, loop %d\n", istart_time, i);
         for (j=0; j<32; j++) {   // load data reverse order
	   if(i <= 10) is= ibase+(31-j);
	   else if((i > 10) && (i <= 16)) is= irise*(i-10)+ibase+(31-j);
	   else is= (irise*6+ibase+(31-j))-(i-16)*ifall;
	   if(is <= 0) is =0;
	   if(is >= 4095) is = 4095;
	   if(j != 31) il = (is & 0xfff)+ 0x8000;
	   else il =(is & 0xfff)+ 0xc000;
	   //          printf("is = %x, loop %d, chnl %d \n", is, i,j);
	   buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_test_data+(il<<16);  // load PMT test data
	   ijk=1;
	   k=1;
	   ijk = pcie_send(hDev, ijk, k, px);
         }
	 //        scanf("%d",&ik);
        }
	//
	//     set PMT test data pulse
	//
        imod=imod_fem;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_pulse+(0x1<<16);  // send pulse for PMT test data
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
      }
      //
      //     set up PMT
      //
      

      
      
      //
      //
      //
      if(ifr ==0) {
	//         ifr=1;
        printf(" buffer allocation 1\n");
        dwDMABufSize = 60000;
        dwStatus = WDC_DMAContigBufLock(hDev1, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
        if (WD_STATUS_SUCCESS != dwStatus) {
	  printf("Failed locking a rec Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
	  printf("enter 1 to continue \n");
	  scanf("%d",&is);
        }
        else {
	  u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
	  printf(" buffer allocation lower address = %x\n", u32Data);
	  u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
	  printf(" buffer allocation higher address = %x\n", u32Data);
        }
	/* set tx mode register */
	
        u32Data = 0x00002000;
        dwOffset = tx_md_reg;
        dwAddrSpace =cs_bar;
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
	
	/* write this will abort previous DMA */
        dwAddrSpace =2;
        dwOffset = cs_dma_msi_abort;
        u32Data = dma_abort;
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
	/* clear DMA register after the abort */
        dwAddrSpace =2;
        dwOffset = cs_dma_msi_abort;
        u32Data = 0;
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
        printf(" initial abort finished \n");
      }
      
      buffp_rec32 = pbuf_rec;
      if(icont == 1) nwrite_byte = ibytec;
      else nwrite_byte = dwDMABufSize;
      for (is=0; is< nwrite_byte/4; is++) {
	buffp_rec32[is]=0;
      }
      //
      //
      for (is=1; is<3; is++) {
        tr_bar = t1_tr_bar;
        r_cs_reg = r1_cs_reg;
        dma_tr = dma_tr1;
        if(is == 2) {
	  tr_bar = t2_tr_bar;
	  r_cs_reg = r2_cs_reg;
	  dma_tr = dma_tr2;
        }
        if(idebug ==1) printf(" is = %d\n",is);
	/** initialize the receiver ***/
        u32Data = cs_init;
        dwOffset = r_cs_reg;
        dwAddrSpace =cs_bar;
	//
	// rreceiver only get initialize for the 1st time
	//
	//
	//        if(ifr ==0) {
	if(icont != 1) printf(" initialize the input fifo\n");
	WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
	//        }
	/** start the receiver **/
        dwAddrSpace = cs_bar;
	//        u32Data = cs_start+(nwrite*2)*4;   /* 32 bits mode == 4 bytes per word *2 fibers **/
        u32Data = cs_start+nwrite_byte;   /* 32 bits mode == 4 bytes per word *2 fibers **/
	//**         if(iwrite != 1) printf(" DMA loop %d with DMA data length %d \n", iv, nwrite_byte);
        dwOffset = r_cs_reg;
        WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      }
      ifr=1;
      //        if((ifr ==0) &&(idebug ==1)) printf(" initial receiver \n");
      //       scanf("%d",&ik);
      /** set up DMA for both transceiver together **/
      
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_low_reg;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_add_high_reg;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      
      /* byte count */
      dwAddrSpace =cs_bar;
      dwOffset = cs_dma_by_cnt;
      //        u32Data = (nwrite)*4*2;      /** twice more data - from fiber 1& 2**/
      u32Data = nwrite_byte;
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      

      /* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = cs_dma_cntrl;
      is = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      if(is == 0) {
	//**         if(iwrite !=1 ) printf(" use 3dw \n");
        u32Data = dma_tr12+dma_3dw_rec;
      }
      else {
        u32Data = dma_tr12+dma_4dw_rec;
	//**        if(iwrite !=1 ) printf(" use 4dw \n");
      }
      WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
      //       if(idebug ==1)
      if(icont != 1) printf(" DMA set up done, byte count = %d\n", nwrite_byte);
      
      //
      //
      //
      if(itrig_ext ==1) {
	//
	//     only need to restart the run if the we use the test data or 1st run
	//
        if((ib == 0)|| (use_pmt != 1)) {
	  imod=imod_trig;
	  buf_send[0]=(imod<<11)+(mb_trig_run)+((0x1)<<16); //set up run
	  i=1;
	  k=1;
	  i = pcie_send(hDev, i, k, px);
        }
	
        if(itrig_pulse == 1) {
	  if(imulti == 1) {
	    for (is =0; is< n_trig; is++){
	      imod = imod_trig;
	      buf_send[0]=(imod<<11)+(mb_trig_p1_delay)+((p1_delay)<<16); // set up p1 delay;
	      i=1;
	      k=1;
	      i = pcie_send(hDev, i, k, px);
	      
	      imod = imod_trig;
	      buf_send[0]=(imod<<11)+(mb_trig_p1_width)+((p1_width)<<16); // set up p1 width;
	      i=1;
	      k=1;
	      i = pcie_send(hDev, i, k, px);
	      
	      imod = imod_trig;
	      buf_send[0]=(imod<<11)+(mb_trig_p2_delay)+((p2_delay)<<16); // set up p1 delay;
	      i=1;
	      k=1;
	      i = pcie_send(hDev, i, k, px);
	      
	      imod = imod_trig;
	      buf_send[0]=(imod<<11)+(mb_trig_p2_width)+((p2_width)<<16); // set up p1 width;
	      i=1;
	      k=1;
	      i = pcie_send(hDev, i, k, px);
	      
           imod = imod_trig;
           buf_send[0]=(imod<<11)+(mb_trig_pulse_delay)+((pulse_trig_delay)<<16); // set up triger delay;
           i=1;
           k=1;
           i = pcie_send(hDev, i, k, px);
	   
	   
	   
           usleep(10);
	   
           imod = imod_trig;
           buf_send[0]=(imod<<11)+(mb_trig_pulse1)+((0x1)<<16); // fire pulse 1;
           i=1;
           k=1;
           i = pcie_send(hDev, i, k, px);
	   //
	   //         wait for 100 ms between trigger
	   //
           usleep(10000);
	    }
	  }
	  else {
	    imod = imod_trig;
	    buf_send[0]=(imod<<11)+(mb_trig_p1_delay)+((p1_delay+ib)<<16); // set up p1 delay;
	    i=1;
	    k=1;
	    i = pcie_send(hDev, i, k, px);
	    
	    imod = imod_trig;
	    buf_send[0]=(imod<<11)+(mb_trig_p1_width)+((p1_width)<<16); // set up p1 width;
	    i=1;
	    k=1;
	    i = pcie_send(hDev, i, k, px);
	    
	    imod = imod_trig;
	    buf_send[0]=(imod<<11)+(mb_trig_p2_delay)+((p2_delay)<<16); // set up p1 delay;
	    i=1;
	    k=1;
	    i = pcie_send(hDev, i, k, px);
	    
	    imod = imod_trig;
	    buf_send[0]=(imod<<11)+(mb_trig_p2_width)+((p2_width)<<16); // set up p1 width;
	    i=1;
	    k=1;
	    i = pcie_send(hDev, i, k, px);
	    
	    imod = imod_trig;
	    buf_send[0]=(imod<<11)+(mb_trig_pulse_delay)+((pulse_trig_delay)<<16); // set up triger delay;
	    i=1;
	    k=1;
	    i = pcie_send(hDev, i, k, px);
	    
	    
	    
	    usleep(10);
	    
	    imod = imod_trig;
	    buf_send[0]=(imod<<11)+(mb_trig_pulse1)+((0x1)<<16); // fire pulse 1;
	    i=1;
	    k=1;
	    i = pcie_send(hDev, i, k, px);
	    //
	    //
	    usleep(1000);
	  }
        }
	
       }
      else {
	//
	//      if not use trigger module, controller provide trigger and fire test pulse
	//
        if(ib == 0) {
         imod=0;
         ichip=1;
         buf_send[0]=(imod<<11)+(ichip<<8)+(mb_cntrl_set_run_on)+(0x0<<16); //enable offline run on
         i=1;
         k=1;
         i = pcie_send(hDev, i, k, px);
         usleep(5000);
        }
	
        imod=0;
        ichip=1;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_cntrl_set_trig1+(0x0<<16);  // send trigger
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        printf("controller trig on \n");
	
      }
      //
      //     figure out the test pulse firing and trigger setup
      //
      if(pmt_testpulse == 1) {
	//        if(itrig_ext == 1) {
	//**         printf(" enter 1 to continue on sending test pulse\n");
	//**         scanf("%d",&ik);
	imod =imod_shaper;  /* arm test pulse firing*/
	buf_send[0]=(imod<<11)+mb_shaper_pulse+((0xf)<<16);  // all bits on
	i=1;
	k=1;
	i = pcie_send(hDev, i, k, px);
	//        }
      }
      //printf(" trigger send \n");
      if(irawprint==1) scanf("%d", &i);
      //
      //     wait for trigger to be processed and data send to pc.
      //
      usleep(6000);
      //
      //
      //
      if(icont == 1) {
        idone = 0;
	/***    check to see if DMA is done or not **/	
	/*
	  for (is=0; is<6000000; is++) {
	  dwAddrSpace =cs_bar;
	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
	  WDC_ReadAddr32(hDev1, dwAddrSpace, dwOffset, &u32Data);
	  //         if(idebug ==1) printf(" receive DMA status word %d %X \n", is, u32Data);
	  if((u32Data & dma_in_progress) == 0) {
	  idone =1;
	  }
	  if((u32Data & dma_in_progress) == 0) break;
	  }
	*/
	is=0;
	while(1){
	  dwAddrSpace =cs_bar;
	  u64Data =0;
	  dwOffset = cs_dma_cntrl;
	  WDC_ReadAddr32(hDev1, dwAddrSpace, dwOffset, &u32Data);
	  if((u32Data & dma_in_progress) == 0) {
	    idone =1;
	    break;
	  }else sleep(10);
	  is++;
	  if(is%1000==0) printf("Waiting for DMA to be finished (%d sec.)",is/1000000);
	}
	
	if(idone ==0) printf("DMA is not done \n");
	for (is=0; is < (nwrite_byte/4); is++) {
	  if(!(outf)){
	      if((is%8) ==0) printf("%4d",is);
	      printf("  %8X", buffp_rec32[is]);
	      if((is+1)%8 ==0) printf("\n");
	    }else if(idone){
	    if(ibin)
	      fwrite(&buffp_rec32[is],sizeof(buffp_rec32[is]),1,outf);
	    else{
	      if((is%8) ==0) fprintf(outf,"%4d",is);
	      fprintf(outf,"  %8X", buffp_rec32[is]);
	      if((is+1)%8 ==0) fprintf(outf,"\n");
	    }
	  }
	}
	//if((is+1)%8 !=0) printf("\n");
      }
      
       else {
	 printf("nwrite_byte = %d %x\n", nwrite_byte, nwrite_byte);
	 nremain_tran1=0;
	 idone=0;
	 for(i=0; i< 1000000; i++) {
	   usleep(80000);                     // have to wait long enough for other board data show up
	   dwAddrSpace =cs_bar;
	   u64Data =0;
	   dwOffset = t1_cs_reg;
	   WDC_ReadAddr64(hDev1, dwAddrSpace, dwOffset, &u64Data);
	   u32Data=u64Data;
	   printf (" transmitter 1 loop %d status = %8X \n",i,u32Data);
	   u32Data=u64Data>>32;
	   printf (" receiver 1 loop %d status = %8X \n",i,u32Data);
	   if(nremain_tran1 == u32Data) idone=1;
	   else nremain_tran1 = u32Data;
	   if(idone ==1) break;
	 }
	 
	 dwAddrSpace =cs_bar;
	 dwOffset = cs_dma_by_cnt;
	 WDC_ReadAddr64(hDev1, dwAddrSpace, dwOffset, &u64Data);
	 printf(" DMA word count before abort = %8x %8x \n",(u64Data>> 32), (u64Data & 0xffffffff));
	 printf(" register data load is %8x \n", nwrite_byte);
	 nread_dma = u64Data & 0xfffffff;
	 //
	 //
	 //
	 dwAddrSpace =cs_bar;
	 dwOffset = t1_cs_reg;
	 WDC_ReadAddr64(hDev1, dwAddrSpace, dwOffset, &u64Data);
	 u32Data=u64Data>>32;
	 printf (" receiver 1 status = %8X \n",u32Data);
	 //
	 //
	 dwAddrSpace =cs_bar;
	 dwOffset = t2_cs_reg;
	 WDC_ReadAddr64(hDev1, dwAddrSpace, dwOffset, &u64Data);
	 u32Data=u64Data>>32;
	 printf (" receiver 2 status = %8X \n",u32Data);
	 //
	 //
	 //
	 /*
	   for (is=0; is< (((nwrite_byte-nread_dma)/4)+8); is++) {
	   if((is%8) ==0) printf("%4d",is);
	   printf("  %8X", buffp_rec32[is]);
	   if((is+1)%8 ==0) printf("\n");
	   }
	 */
	 WDC_DMASyncCpu(pDma_rec);
	 WDC_DMASyncIo(pDma_rec);
	 ik= (nwrite_byte-nread_dma)/4;
	 nremain = (nwrite_byte - (nremain_tran1 &0xffff)) - (nwrite_byte- nread_dma);
	 printf(" nremain = %d, nremain/4 = %d \n", nremain, nremain/4);
	 
	 for (is =0; is < ik; is++) {
	   read_array[is] = *buffp_rec32++;
	 }
	 
	 scanf("%d",&is);
	 
	 for (is=0; is< ((nremain/8)+4); is++) {
	   dwAddrSpace = t1_tr_bar;
	   u64Data =0;
	   dwOffset =0;
	   WDC_ReadAddr64(hDev1, dwAddrSpace, dwOffset, &u64Data);
	   u32Data =   (u64Data>> 32) & 0xffffffff;
	   //         buffp_rec32[ik+is*2+1] = u32Data;
	   read_array[ik+is*2+1] = u32Data;
	   //         printf(" %d u64Data =  %8X ", is , u32Data);
	   u32Data =   u64Data& 0xffffffff;
	   //         buffp_rec32[ik+is*2] = u32Data;
	   read_array[ik+is*2] = u32Data;
	   //         printf(" %8X \n", u32Data);
	 }
	 for (is=0; is < (((nwrite_byte - (nremain_tran1 & 0xffff))/4)+8); is++) {
         if((is%8) ==0) printf("%4d",is);
         printf("  %8X", read_array[is]);
         if((is+1)%8 ==0) printf("\n");
	 }
	 
	 /*
	   for (is=0; is< ((nremain/8)+4); is++) {
	   dwAddrSpace = t1_tr_bar;
	   u64Data =0;
	   dwOffset =0;
	   WDC_ReadAddr32(hDev1, dwAddrSpace, dwOffset, &u32Data);
	   printf(" %d u64Data =  %8X \n", is , u32Data);
	   }
	 */
	 //
	 //     set up abort
	 //
         /* write this will abort previous DMA */
	 dwAddrSpace =2;
	 dwOffset = cs_dma_msi_abort;
	 u32Data = dma_abort;
	 WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
	 /* clear DMA register after the abort */
	 dwAddrSpace =2;
	 dwOffset = cs_dma_msi_abort;
	 u32Data = 0;
	 WDC_WriteAddr32(hDev1, dwAddrSpace, dwOffset, u32Data);
	 printf(" initial abort finished \n");
	 scanf("%d",&ik);
       } 
      usleep(10000);
    }
    if(outf)
      fclose(outf);
}

