#ifndef NEVIS_PCIE_UTILS_C
#define NEVIS_PCIE_UTILS_C
/************************************************************************
*  File: pcie_diag.c
*
*  Sample user-mode diagnostics application for accessing PCIE
*  devices using WinDriver's API.
*  Code was generated by DriverWizard v10.21.
*
*  Jungo Confidential. Copyright (c) 2011 Jungo Ltd.  http://www.jungo.com
*************************************************************************/
#include "wd_utils.c"

static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send);
static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec);
static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit);
static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem);
static int pmt_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe);
static int pmt_link_setup(WDC_DEVICE_HANDLE hDev, int imod_xmit, int imod_st, int supernova);

static int pmt_adc_setup(WDC_DEVICE_HANDLE hDev, int imod_fem, int iframe)
{
  
#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_dram_reset     31
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000

//    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
//    static unsigned long long u64Data, u64Data1;
//    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
//    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[1000];
//    ,read_array1[40000];
//    static UINT32 read_array_c[40000];
//    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
//    unsigned short idcm_read_array[40000],read_array_s[1600000];
//    static UINT32 idcm_read_array32[40000];
//    static UINT32 idcm_send_array[400000];
//    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
//    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
//    PVOID pbuf;
//    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_xmit,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
    static int   pmt_deadtime,pmt_mich_window;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan, pmt_precount;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;


    UINT32 *px, *py, *py1;

    FILE *outf,*inpf;

//
//
//
    pmt_deadtime = 41; ///set deadtime long so it will not double fired on trailling edge
    pmt_mich_window = 2;
//
//
    threshold0 = 10;   // 100 discriminator threshold 0
    threshold1 = 15;   // 150 discriminator threshold 1
    cos_mult = 1;       // cosmic ray multiplicity threshold
    cos_thres = 20;    // cosmic ray sum ph threshold
    pmt_precount = 1; // set PMT precount
    pmt_words=40;      // number of word to read

//
//
//
 // turn on the Stratix III power supply

    px = buf_send;
    py = read_array;

    imod=imod_fem;
    ichip =1;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_power_add+(0x0<<16); //turn module 11 power on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
    usleep(200000);  // wait for 200 ms
//     printf(" enable number of loop\n");
//     scanf("%d",&nloop);

    usleep(10000); // wait for 10ms
    inpf = fopen("/home/ub/feb_pmt_fpga_test_new_head","r");
    imod=imod_fem;
    ichip=mb_feb_conf_add;
    buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }

             /* read data as characters (28941) */
    usleep(1000);   // wait fior a while
    nsend = 500;
    count = 0;
    counta= 0;
    ichip_c = 7; // set ichip_c to stay away from any other command in the
    dummy1 =0;
    while (fread(&charchannel,sizeof(char),1,inpf)==1) {
     carray[count] = charchannel;
     count++;
     counta++;
     if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
      buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
      send_array[0] =buf_send[0];
      if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
      ,carray[2], carray[3]);
      for (ij=0; ij< nsend; ij++) {
       if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
       else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
      nword =nsend+1;
      i=1;
//       if(dummy1 == 0)
      ij = pcie_send(hDev, i, nword, px);
      nanosleep(&tim , &tim2);
      dummy1 = dummy1+1;
      count =0;
     }
    }
    if(feof(inpf)) {
     printf("You have reached the end-of-file word count= %d %d\n", counta, count);
     buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
     if ( count > 1) {
      if( ((count-1)%2) ==0) {
       ik =(count-1)/2;
      }
      else {
       ik =(count-1)/2+1;
      }
      ik=ik+2;   // add one more for safety
      printf("ik= %d\n",ik);
      for (ij=0; ij<ik; ij++){
       if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
       else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
       send_array[ij+1] = buf_send[ij+1];
      }
     }
     else ik=1;

     for (ij=ik-10; ij< ik+1; ij++) {
       printf("Last data = %d, %x\n",ij,buf_send[ij]);
     }

     nword =ik+1;
     i=1;
     i = pcie_send(hDev, i, nword, px);
    }
    usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
    fclose(inpf);
//
//
//
    printf(" enter 1 to reset the dram in module %d \n", imod);
    scanf("%d",&ik);
 //      ik =1;
    if(ik ==1) {
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x1<<16);  // turm the DRAM reset on
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+31+(0x0<<16);  // turm the DRAM reset off
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

     usleep(5000);    // wait for 5 ms for DRAM to be initialized
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+6+(imod<<16);  // set module number
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);


    }
//       printf(" enter 1 to read system status \n");
//       scanf("%d",&ik);

    nword =1;
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receive data word = %x, %x \n", read_array[0], read_array[1]);

//
//     set PMT inhibit size to 625
//
//    imod=imod_fem;
//    ichip=3;
//    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_inhib_size+(625<<16);  // set module number
//    i=1;
//    k=1;
//    i = pcie_send(hDev, i, k, px);
//
//     set PMT delay 0 to 4
//
    for (ik=0; ik<40; ik++) {

     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_ch_set+(ik<<16);  // set channel number to be download
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

      usleep(100);

     imod=imod_fem;
     ichip=3;
     idelay0=4;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay0+(idelay0<<16);  // set delay0
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT delay1 to 12
//
     imod=imod_fem;
     ichip=3;
     idelay1=12;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_delay1+(idelay1<<16);  // set delay 1
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT precount
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_precount+(pmt_precount<<16);  // set pmt precount
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 0 to 10
//
     imod=imod_fem;
     ichip=3;
//      threshold0=100;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh0+(threshold0<<16);  // set threshold 0
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT threshold 1 to 20
//
     imod=imod_fem;
     ichip=3;
//      threshold1=150;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_thresh1+(threshold1<<16);  // set threshold 1
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT data words to 40
//
     imod=imod_fem;
     ichip=3;
//    pmt_words=40;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_words+(pmt_words<<16);  // set pmt_words
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);

//
//     set PMT deadtime
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_deadtime+(pmt_deadtime<<16);  // set pmt dead timr
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
//
//     set PMT Michael window
//
     imod=imod_fem;
     ichip=3;
     buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_window+(pmt_mich_window<<16);  // set pmt Michael window
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
//
//     set PMT cosmic ray trigger multiplicity to 2
//
    imod=imod_fem;
    ichip=3;
//      cos_mult=2;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_mul+(cos_mult<<16);  // set cosmic ray trigger mul
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     set PMT cosmic ray trigger pulse height
//
    imod=imod_fem;
    ichip=3;
//      cos_thres=20;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_cos_thres+(cos_mult<<16);  // set cosmic ray trigger peak
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     disable the top chanell
//
    imod=imod_fem;
    ichip=3;
    en_top=0xff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_top+(en_top<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     disable the upper chanell
//
    imod=imod_fem;
    ichip=3;
    en_upper=0xffff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_upper+(en_upper<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     enable all lower channel
//
    imod=imod_fem;
    ichip=3;
    en_lower=0xffff;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_en_lower+(en_lower<<16);  // enable/disable channel
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     set maximum block size
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_blocksize+(0xffff<<16);  // set max block size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//
    imod=imod_fem;
    ichip=3;
    //buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate_size+(0x50<<16);  // set gate size
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_gate_size+(0xa0<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//    set beam delay
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_delay+(0x5<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//    set beam size window
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_beam_size+(0x40<<16);  // set gate size
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);


//
//
//     &&&&&&&&&&&&&&&
//
//     set a_id
//
    a_id =0x20;
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_a_id+(a_id<<16);  // set a_id
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//     enable hold
//
//         imod=11;
    imod = imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_hold_enable+(0x1<<16);  // enable the hold
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);


//
//     work on the ADC -- set reset pulse
//
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x1<<16); // reset goes low
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_reset)+(0x0<<16); // reset goes high
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//      enable ADC clock,
//
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+(0x7<<16); //set spi address
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    imod=imod_fem;
    ichip=5;
    buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0xffff<<16); //load spi data, clock gate enable
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//        load ADC sync data pattern  + set MSB 1st
//
    for (is=1; is<7; is++) {
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0b00<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x1400<<16); //msb 1st
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
    printf(" enter 1 to continue FPGA ADC receiver reset\n");
//    scanf("%d",&ik);
//
//    send FPGA ADC receiver reset
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_rxreset+(0x1<<16);  // FPGA ADC receiver reset on
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
//
//      readback status
//
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receiv e data word -- after reset = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
    printf(" enter 1 to continue FPGA ADC receiver align\n");
//    scanf("%d",&ik);
//
//    send FPGA ADC align
//
    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pmt_align_pulse+(0x0<<16);  // FPGA ADC receiver reset off
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);

    usleep(5000); // wait for 5ms

//
//      readback status
//
    i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver

    imod=imod_fem;
    ichip=3;
    buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
    i=1;
    k=1;
    i = pcie_send(hDev, i, k, px);
    py = read_array;
    i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
    printf("receive data word -- after align = %x, %x \n", read_array[0], read_array[1]);
    printf(" module = %d, command = %d \n", ((read_array[0]>>11) & 0x1f), (read_array[0] &0xff));
    printf(" ADC right dpa lock     %d \n", ((read_array[0]>>17) & 0x1));
    printf(" ADC left  dpa lock     %d \n", ((read_array[0]>>18) & 0x1));
    printf(" block error 2          %d \n", ((read_array[0]>>19) & 0x1));
    printf(" block error 1          %d \n", ((read_array[0]>>20) & 0x1));
    printf(" pll lcoked             %d \n", ((read_array[0]>>21) & 0x1));
    printf(" superNova mem ready    %d \n", ((read_array[0]>>22) & 0x1));
    printf(" beam      mem ready    %d \n", ((read_array[0]>>23) & 0x1));
    printf(" ADC right PLL locked   %d \n", ((read_array[0]>>24) & 0x1));
    printf(" ADC left PLL locked    %d \n", ((read_array[0]>>25) & 0x1));
    printf(" ADC align cmd right    %d \n", ((read_array[0]>>26) & 0x1));
    printf(" ADC align cmd left     %d \n", ((read_array[0]>>27) & 0x1));
    printf(" ADC align done right   %d \n", ((read_array[0]>>28) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" ADC align done left    %d \n", ((read_array[0]>>29) & 0x1));
    printf(" Neutrino data empty    %d \n", ((read_array[0]>>30) & 0x1));
    printf(" Neutrino Header empty  %d \n", ((read_array[0]>>31) & 0x1));
//
//
//
//
    printf(" enter 1 to continue after ADC alignment \n");
//    scanf("%d",&ik);
//
//
//
    for (is=1; is<7; is++) {
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_spi_add)+((is & 0xf)<<16); //set spi address
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
     imod=imod_fem;
     ichip=5;
     buf_send[0]=(imod<<11)+(ichip<<8)+(mb_pmt_adc_data_load)+(0x0300<<16); //sync pattern, b for sync, 7 for skew, 3 for normal
     i=1;
     k=1;
     i = pcie_send(hDev, i, k, px);
    }
    return i;





}

static int pmt_link_setup(WDC_DEVICE_HANDLE hDev, int imod_xmit, int imod_st, int supernova)
{
#include "wdc_defs.h"
#include "wdc_defs.h"
#define poweroff      0x0
#define poweron       0x1
#define configure_s30 0x2
#define configure_s60 0x3
#define configure_cont 0x20
#define rdstatus      0x80
#define loopback        0x04

#define dcm2_run_off  254
#define dcm2_run_on   255

#define dcm2_online   2
#define dcm2_setmask  3
#define dcm2_offline_busy 4
#define dcm2_load_packet_a 10
#define dcm2_load_packet_b 11
#define dcm2_offline_load 9
#define dcm2_status_read 20
#define dcm2_led_sel     29
#define dcm2_buffer_status_read 30
#define dcm2_status_read_inbuf 21
#define dcm2_status_read_evbuf 22
#define dcm2_status_read_noevnt 23
#define dcm2_zero 12
#define dcm2_compressor_hold 31

#define dcm2_5_readdata 4
#define dcm2_5_firstdcm 8
#define dcm2_5_lastdcm  9
#define dcm2_5_status_read 5
#define dcm2_5_source_id 25
#define dcm2_5_lastchnl 24

#define dcm2_packet_id_a 25
#define dcm2_packet_id_b 26
#define dcm2_hitformat_a 27
#define dcm2_hitformat_b 28

#define part_run_off  254
#define part_run_on   255
#define part_online   2
#define part_offline_busy 3
#define part_offline_hold 4
#define part_status_read 20
#define part_source_id 25


#define  t1_tr_bar 0
#define  t2_tr_bar 4
#define  cs_bar 2

/**  command register location **/

#define  tx_mode_reg 0x28
#define  t1_cs_reg 0x18
#define  r1_cs_reg 0x1c
#define  t2_cs_reg 0x20
#define  r2_cs_reg 0x24

#define  tx_md_reg 0x28

#define  cs_dma_add_low_reg 0x0
#define  cs_dma_add_high_reg  0x4
#define  cs_dma_by_cnt 0x8
#define  cs_dma_cntrl 0xc
#define  cs_dma_msi_abort 0x10

/** define status bits **/

#define  cs_init  0x20000000
#define  cs_mode_p 0x8000000
#define  cs_mode_n 0x0
#define  cs_start 0x40000000
#define  cs_done  0x80000000

#define  dma_tr1  0x100000
#define  dma_tr2  0x200000
#define  dma_tr12 0x300000
#define  dma_3dw_trans 0x0
#define  dma_4dw_trans 0x0
#define  dma_3dw_rec   0x40
#define  dma_4dw_rec   0x60
#define  dma_in_progress 0x80000000

#define  dma_abort 0x2

#define  mb_cntrl_add     0x1
#define  mb_cntrl_test_on 0x1
#define  mb_cntrl_test_off 0x0
#define  mb_cntrl_set_run_on 0x2
#define  mb_cntrl_set_run_off 0x3
#define  mb_cntrl_set_trig1 0x4
#define  mb_cntrl_set_trig2 0x5
#define  mb_cntrl_load_frame 0x6
#define  mb_cntrl_load_trig_pos 0x7

#define  mb_feb_power_add 0x1
#define  mb_feb_conf_add 0x2
#define  mb_feb_pass_add 0x3

#define  mb_feb_lst_on          1
#define  mb_feb_lst_off         0
#define  mb_feb_rxreset         2
#define  mb_feb_align           3
#define  mb_feb_pll_reset       5


#define  mb_feb_adc_align       1
#define  mb_feb_a_nocomp        2
#define  mb_feb_b_nocomp        3
#define  mb_feb_blocksize       4
#define  mb_feb_timesize        5
#define  mb_feb_mod_number      6
#define  mb_feb_a_id            7
#define  mb_feb_b_id            8
#define  mb_feb_max             9

#define  mb_feb_test_source    10
#define  mb_feb_test_sample    11
#define  mb_feb_test_frame     12
#define  mb_feb_test_channel   13
#define  mb_feb_test_ph        14
#define  mb_feb_test_base      15
#define  mb_feb_test_ram_data  16

#define  mb_feb_a_test         17
#define  mb_feb_b_test         18

#define  mb_feb_rd_status      20

#define  mb_feb_a_rdhed        21
#define  mb_feb_a_rdbuf        22
#define  mb_feb_b_rdhed        23
#define  mb_feb_b_rdbuf        24

#define  mb_feb_read_probe     30
#define  mb_feb_adc_reset      33

#define  mb_a_buf_status       34
#define  mb_b_buf_status       35
#define  mb_a_ham_status       36
#define  mb_b_ham_status       37

#define  mb_feb_a_maxwords     40
#define  mb_feb_b_maxwords     41

#define  mb_feb_hold_enable    42

#define  mb_pmt_adc_reset       1
#define  mb_pmt_spi_add         2
#define  mb_pmt_adc_data_load   3

#define  mb_xmit_conf_add 0x2
#define  mb_xmit_pass_add 0x3

#define  mb_xmit_modcount 0x1
#define  mb_xmit_enable_1 0x2
#define  mb_xmit_enable_2 0x3
#define  mb_xmit_test1 0x4
#define  mb_xmit_test2 0x5

#define   mb_xmit_testdata  10

#define  mb_xmit_rdstatus 20
#define  mb_xmit_rdcounters 21
#define  mb_xmit_link_reset    22
#define  mb_opt_dig_reset   23
#define  mb_xmit_dpa_fifo_reset    24
#define  mb_xmit_dpa_word_align    25
#define  mb_xmit_link_pll_reset    26

#define  mb_trig_run                1
#define  mb_trig_frame_size         2
#define  mb_trig_deadtime_size      3
#define  mb_trig_active_size        4
#define  mb_trig_delay1_size        5
#define  mb_trig_delay2_size        6

#define  mb_trig_calib_delay        8

#define  mb_trig_prescale0         10
#define  mb_trig_prescale1         11
#define  mb_trig_prescale2         12
#define  mb_trig_prescale3         13
#define  mb_trig_prescale4         14
#define  mb_trig_prescale5         15
#define  mb_trig_prescale6         16
#define  mb_trig_prescale7         17
#define  mb_trig_prescale8         18

#define  mb_trig_mask0             20
#define  mb_trig_mask1             21
#define  mb_trig_mask2             22
#define  mb_trig_mask3             23
#define  mb_trig_mask4             24
#define  mb_trig_mask5             25
#define  mb_trig_mask6             26
#define  mb_trig_mask7             27
#define  mb_trig_mask8             28

#define  mb_trig_rd_param          30
#define  mb_trig_pctrig            31
#define  mb_trig_rd_status         32
#define  mb_trig_reset             33
#define  mb_trig_calib             34
#define  mb_trig_rd_gps            35

#define  mb_trig_sel1              40
#define  mb_trig_sel2              41
#define  mb_trig_sel3              42
#define  mb_trig_sel4              43

#define  mb_trig_p1_delay          50
#define  mb_trig_p1_width          51
#define  mb_trig_p2_delay          52
#define  mb_trig_p2_width          53
#define  mb_trig_p3_delay          54
#define  mb_trig_p3_width          55
#define  mb_trig_pulse_delay       58

#define  mb_trig_pulse1            60
#define  mb_trig_pulse2            61
#define  mb_trig_pulse3            62

#define  mb_shaper_pulsetime        1
#define  mb_shaper_dac              2
#define  mb_shaper_pattern          3
#define  mb_shaper_write            4
#define  mb_shaper_pulse            5
#define  mb_shaper_entrig           6

#define  mb_feb_pmt_gate_size      47
#define  mb_feb_pmt_beam_delay     48
#define  mb_feb_pmt_beam_size      49

#define  mb_feb_pmt_ch_set         50
#define  mb_feb_pmt_delay0         51
#define  mb_feb_pmt_delay1         52
#define  mb_feb_pmt_precount       53
#define  mb_feb_pmt_thresh0        54
#define  mb_feb_pmt_thresh1        55
#define  mb_feb_pmt_thresh2        56
#define  mb_feb_pmt_thresh3        57
#define  mb_feb_pmt_width          58
#define  mb_feb_pmt_deadtime       59
#define  mb_feb_pmt_window         60
#define  mb_feb_pmt_words          61
#define  mb_feb_pmt_cos_mul        62
#define  mb_feb_pmt_cos_thres      63
#define  mb_feb_pmt_mich_mul       64
#define  mb_feb_pmt_mich_thres     65
#define  mb_feb_pmt_beam_mul       66
#define  mb_feb_pmt_beam_thres     67
#define  mb_feb_pmt_en_top         68
#define  mb_feb_pmt_en_upper       69
#define  mb_feb_pmt_en_lower       70
#define  mb_feb_pmt_blocksize      71

#define  mb_feb_pmt_test           80
#define  mb_feb_pmt_clear          81
#define  mb_feb_pmt_test_data      82
#define  mb_feb_pmt_pulse          83

#define  mb_feb_pmt_rxreset        84
#define  mb_feb_pmt_align_pulse    85
#define  mb_feb_pmt_rd_counters    86

#define  dma_buffer_size        10000000

//    static DWORD dwAddrSpace;

    static UINT32 u32Data;
    static unsigned short u16Data;
//    static unsigned long long u64Data, u64Data1;
//    static DWORD dwOffset;
    static long imod,ichip;
    unsigned short *buffp;

/*
    WDC_ADDR_MODE mode;
    WDC_ADDR_RW_OPTIONS options;
*/
    static UINT32 i,j,k,ifr,nread,iprint,iwrite,ik,il,is,checksum;
//    static UINT32 istop,newcmd,irand,ioffset,kword,lastchnl,ib;
    static UINT32 send_array[40000],read_array[1000];
//    ,read_array1[40000];
//    static UINT32 read_array_c[40000];
//    static UINT32 read_comp[8000];
    static UINT32 nmask,index,itmp,nword_tot,nevent,iv,ijk,islow_read;
    static UINT32 imod_p,imod_trig,imod_shaper;
//    unsigned short idcm_read_array[40000],read_array_s[1600000];
//    static UINT32 idcm_read_array32[40000];
//    static UINT32 idcm_send_array[400000];
//    static UINT32 idcm_verify_array[400000];
    static int icomp_l,comp_s,ia,ic,ihuff;
//    UINT32 *idcm_send_p,*idcm_verify_p,*pbuffp_rec;
//    DWORD dwDMABufSize;
//    PVOID pbuf;
//    WD_DMA *pDma;
    DWORD dwStatus;
    DWORD dwOptions = DMA_FROM_DEVICE;
    UINT32 iread,icheck,izero;
    UINT32 buf_send[40000];
    static int   count,num,counta,nword,ireadback,nloop,ierror;
    static int   ij,nsend,iloop,inew,idma_readback,iadd,jevent;
    static int   itest,irun,ichip_c,dummy1,itrig_c;
    static int  idup,ihold,idouble,ihold_set,istatus_read;
    static int  idone,tr_bar,t_cs_reg,r_cs_reg,dma_tr;
    static int   timesize,ipulse,ibase,a_id,itrig_delay;
    static int   iset,ncount,nsend_f,nwrite,itrig_ext;
    static int   imod_fem,idiv,isample;
    static int   iframe_length, itrig,idrift_time,ijtrig;
    static int   idelay0, idelay1, threshold0, threshold1, pmt_words;
    static int   cos_mult, cos_thres, en_top, en_upper, en_lower;
    static int   irise, ifall, istart_time, use_pmt, pmt_testpulse;
    static int   ich_head, ich_sample, ich_frm,idebug,ntot_rec,nred;
    static int   ineu,ibusy_send,ibusy_test,ihold_word,ndma_loop;
    static int   irawprint,ifem_fst,ifem_lst,ifem_loop;
    static int   pmt_deadtime,pmt_mich_window;
    static int   oframe,osample,odiv,cframe,csample,cdiv;
    static int   idac_shaper, pmt_dac_scan;
    unsigned char    charchannel;
    unsigned char    carray[4000];
    struct timespec tim, tim2;
    tim.tv_sec = 0;
    tim.tv_nsec =128000;


    PVOID pbuf_rec;
    WD_DMA *pDma_rec;
    DWORD dwOptions_send = DMA_TO_DEVICE | DMA_ALLOW_CACHE;
//    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_CACHE | DMA_ALLOW_64BIT_ADDRESS;
    DWORD dwOptions_rec = DMA_FROM_DEVICE | DMA_ALLOW_64BIT_ADDRESS;


    UINT32 *px, *py, *py1;
//
//
     px = buf_send;
     py = read_array;
     iprint == 1;
     printf(" link setup imod_st =%d, imod_xmit %d \n", imod_st, imod_xmit);
//
//     now reset all the link port receiver PLL
//
     for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
       imod=imod_fem;
       printf(" reset the link PLL for module %x \n", imod);
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_pll_reset+(0x0<<16);    // reset LINKIN PLL
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);   // give PLL time to reset
      }
//
//
//

     for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = read_array;
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("FEM module %d status word after PLL reset = %x, %x \n", imod, read_array[0], read_array[1]);
     }


//
//     now reset all the link port receiver
//
//-     for (imod_fem = (imod_st-1); imod_fem > imod_xmit; imod_fem--) {
//-       imod=imod_fem;
//-       printf(" reset the link for module %d \n", imod);
//-       ichip=4;
//-       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
//-       i=1;
//-       k=1;
//-       i = pcie_send(hDev, i, k, px);
//
//
//-       ichip=4;
//-       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
//-       i=1;
//-       k=1;
//-       i = pcie_send(hDev, i, k, px);
//-      }

 //
 //
 //
 //
//     set up xmit module  -- module count
//
      imod=imod_xmit;
      ichip=3;
//                  -- number of FEM module -1, counting start at 0
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_modcount+((imod_st-imod_xmit-1)<<16);
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     rest optical
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_opt_dig_reset+(0x1<<16);  // set optical reset on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     enable Neutrino/superNova Token Passing
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
//      if(supernova == 0) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x1<<16);  // enable token 1 pass
//      else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_1+(0x0<<16);  // edisable token 1 pass
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
      if(supernova == 0) buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x0<<16);  // disable token 2 pass
      else buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_enable_2+(0x1<<16);  // enable token 2 pass
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
//       printf(" enter 1 to reset the DPA \n");
//       scanf("%d",&ik);

//
//
//       reset XMIT LINK IN DPA
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_pll_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      usleep(1000);
//
//     reset XMIT LINK IN DPA
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_link_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//     wait for 10ms just in case
//
      usleep(10000);
      printf(" XMIT FIFO reset \n");
//
//     reset XMIT FIFO reset
//
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_fifo_reset+(0x1<<16);  //  reset XMIT LINK IN DPA
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

//
//    set up last module to the module next to XMIT
//
      imod=imod_xmit+1;
      printf(" set last module on, module address %d\n", imod);
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);

      for (is=0; is<1; is++) {
//
//      test re-align circuit
//
        imod=imod_xmit;
        ichip=3;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_xmit_dpa_word_align+(0x1<<16);  //  send alignment pulse
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);

//        printf(" enter 1 to set continue on re-align circuit \n");
//        scanf("%d",&ik);
      }
      usleep(5000); //wait for 5 ms
//      printf(" XMIT re-align done \n");
//      scanf("%d",&ik);

      nword =1;

      i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
      imod=imod_xmit;
      ichip=3;
      buf_send[0]=(imod_xmit<<11)+(ichip<<8)+mb_xmit_rdstatus+(0x0<<16);  // read out status

      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
      //py = &read_array;
      py = read_array;
      i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
      printf("xmit status word = %x, %x \n", read_array[0], read_array[1]);


//
//    set up last module to the module next to XMIT
//
      imod=imod_xmit+1;
      printf(" set last module off, module address %d\n", imod);
      ichip=4;
      buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//
//
      printf(" finish XMIT alignment \n");
      scanf("%d",&ik);
//
//
//
//

//
//
//     now reset all the link port receiver
//
      imod_fem = imod_xmit+1;
      while (imod_fem < imod_st){
       imod= imod_fem+1;
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_on+(0x0<<16);    // set last module on
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       printf(" set last modulen, module address -- alignment %d\n", imod);
       imod =imod_fem;
       printf(" reset the link for module %d \n", imod);
       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_rxreset+(0x0<<16);    // reset LINKIN DPA
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);

       ichip=4;
       buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_align+(0x0<<16);    // send alignment command
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       usleep(1000);
//
//
//       printf(" finish FEM module %d alignment \n", imod);
//       scanf("%d",&ik);
//
       imod=imod_fem+1;
       if(imod != imod_st) {
        ichip=4;
        buf_send[0]=(imod<<11)+(ichip<<8)+mb_feb_lst_off+(0x0<<16);    // set last module off
        i=1;
        k=1;
        i = pcie_send(hDev, i, k, px);
        printf(" set last module off, module address -- alignment%d\n", imod);
       }
       imod_fem=imod_fem+1;
      }





//


     for (imod_fem = (imod_xmit+1); imod_fem< (imod_st+1); imod_fem++) {
       i = pcie_rec(hDev,0,1,nword,iprint,py);     // init the receiver
       imod=imod_fem;
       ichip=3;
       buf_send[0]=(imod<<11)+(ichip<<8)+20+(0x0<<16);  // read out status
       i=1;
       k=1;
       i = pcie_send(hDev, i, k, px);
       py = read_array;
       usleep(100);
       i = pcie_rec(hDev,0,2,nword,iprint,py);     // read out 2 32 bits words
       if(iprint == 1) printf("FEM module %d status word = %x, %x \n", imod, read_array[0], read_array[1]);
     }
     return i;

}

static int pcie_send(WDC_DEVICE_HANDLE hDev, int mode, int nword, UINT32 *buff_send)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_send;
    static WD_DMA *pDma_send;
    static DWORD dwStatus;
    static DWORD dwOptions_send = DMA_TO_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static PVOID pbuf_send;
    int nwrite,i,j, iprint;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_send, dwOptions_send, dwDMABufSize, &pDma_send);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_send = (UINT32*)(pbuf_send);
    }
    iprint =0;
    if(mode ==1 ) {
      for (i=0; i< nword; i++) {
        *(buf_send+i) = *buff_send++;
/*	printf("%d \n",*(buf_send+i));   */
      }
    }
    if(mode == 0) {
     nwrite = nword*4;
     /*setup transmiiter */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     dwAddrSpace =2;
     u32Data = 0x40000000+nwrite;
     dwOffset = 0x18;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     for (j=0; j< nword; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u32Data = *buff_send++;
       WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     }
     for (i=0; i<20000; i++) {
       dwAddrSpace =2;
       dwOffset = 0xC;
       WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
       if(iprint ==1) printf(" status reed %d %X \n", i, u32Data);
       if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" Data Transfer complete %d \n", i);
       if((u32Data & 0x80000000) == 0) break;
     }
    }
    if( mode ==1 ){
      nwrite = nword*4;
      WDC_DMASyncCpu(pDma_send);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
     /*setup transmiiter */
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nwrite;
      dwOffset = 0x18;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_send->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_send->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nwrite;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100000;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status reed %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0) && iprint == 1) printf(" DMA complete %d \n", i);
	if((u32Data & 0x80000000) == 0) break;
      }
      WDC_DMASyncIo(pDma_send);
    }
    return i;
    }


static int pcie_rec(WDC_DEVICE_HANDLE hDev, int mode, int istart, int nword, int ipr_status, UINT32 *buff_rec)
{
/* imode =0 single word transfer, imode =1 DMA */
#include "wdc_defs.h"
    static DWORD dwAddrSpace;
    static DWORD dwDMABufSize;

    static UINT32 *buf_rec;
    static WD_DMA *pDma_rec;
    static DWORD dwStatus;
    static DWORD dwOptions_rec = DMA_FROM_DEVICE;
    static DWORD dwOffset;
    static UINT32 u32Data;
    static UINT64 u64Data;
    static PVOID pbuf_rec;
    int nread,i,j, iprint,icomp;
    static int ifr=0;

    if (ifr == 0) {
      ifr=1;
      dwDMABufSize = 140000;
      dwStatus = WDC_DMAContigBufLock(hDev, &pbuf_rec, dwOptions_rec, dwDMABufSize, &pDma_rec);
      if (WD_STATUS_SUCCESS != dwStatus) {
             printf("Failed locking a send Contiguous DMA buffer. Error 0x%lx - %s\n", dwStatus, Stat2Str(dwStatus));
      }
      buf_rec = (UINT32*)(pbuf_rec);
    }
    iprint =0;
//    printf(" istart = %d\n", istart);
//   printf(" mode   = %d\n", mode);
/** set up the receiver **/
    if((istart == 1) | (istart == 3)) {
// initalize transmitter mode register...
     printf(" nword = %d \n",nword);
/*
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before set = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }
*/
     dwAddrSpace =2;
     u32Data = 0xf0000008;
     dwOffset = 0x28;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

     /*initialize the receiver */
     dwAddrSpace =2;
     u32Data = 0x20000000;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     /* write byte count **/
     dwAddrSpace =2;
     u32Data = 0x40000000+nword*4;
     dwOffset = 0x1c;
     WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
     if(ipr_status ==1) {
      dwAddrSpace =2;
      u64Data =0;
      dwOffset = 0x18;
      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
     }

     return 0;
    }
    if ((istart == 2) | (istart == 3)) {
//     if(ipr_status ==1) {
//      dwAddrSpace =2;
//      u64Data =0;
//      dwOffset = 0x18;
//      WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
//      printf (" status word before read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
//     }
     if(mode == 0) {
      nread = nword/2+1;
      if(nword%2 == 0) nread = nword/2;
      for (j=0; j< nread; j++) {
       dwAddrSpace =0;
       dwOffset = 0x0;
       u64Data =0xbad;
       WDC_ReadAddr64(hDev,dwAddrSpace, dwOffset, &u64Data);
//       printf("u64Data = %16X\n",u64Data);
       *buff_rec++ = (u64Data &0xffffffff);
       *buff_rec++ = u64Data >>32;
//       printf("%x \n",(u64Data &0xffffffff));
//       printf("%x \n",(u64Data >>32 ));
//       if(j*2+1 > nword) *buff_rec++ = (u64Data)>>32;
//       *buff_rec++ = 0x0;
      }
      if(ipr_status ==1) {
       dwAddrSpace =2;
       u64Data =0;
       dwOffset = 0x18;
       WDC_ReadAddr64(hDev, dwAddrSpace, dwOffset, &u64Data);
       printf (" status word after read = %x, %x \n",(u64Data>>32), (u64Data &0xffff));
      }
      return 0;
     }
     if( mode ==1 ){
      nread = nword*4;
      WDC_DMASyncCpu(pDma_rec);
/*
      printf(" nwrite = %d \n", nwrite);
      printf(" pcie_send hDev = %d\n", hDev);
      printf(" buf_send = %X\n",*buf_send);
*/
/*setup receiver
      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      dwAddrSpace =2;
      u32Data = 0x40000000+nread;
      dwOffset = 0x1c;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
*/
/* set up sending DMA starting address */

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x0;
      u32Data = pDma_rec->Page->pPhysicalAddr & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

      dwAddrSpace =2;
      u32Data = 0x20000000;
      dwOffset = 0x4;
      u32Data = (pDma_rec->Page->pPhysicalAddr >> 32) & 0xffffffff;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* byte count */
      dwAddrSpace =2;
      dwOffset = 0x8;
      u32Data = nread;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);

/* write this will start DMA */
      dwAddrSpace =2;
      dwOffset = 0xc;
      u32Data = 0x00100040;
      WDC_WriteAddr32(hDev, dwAddrSpace, dwOffset, u32Data);
      icomp=0;
      for (i=0; i<20000; i++) {
        dwAddrSpace =2;
	dwOffset = 0xC;
        WDC_ReadAddr32(hDev, dwAddrSpace, dwOffset, &u32Data);
	if(iprint ==1) printf(" DMA status read %d %X \n", i, u32Data);
	if(((u32Data & 0x80000000) == 0)) {
          icomp=1;
          if(iprint == 1) printf(" DMA complete %d \n", i);
        }
	if((u32Data & 0x80000000) == 0) break;
      }
      if(icomp == 0) {
        printf("DMA timeout\n");
        return 1;
      }
      WDC_DMASyncIo(pDma_rec);
      for (i=0; i< nword; i++) {
        *buff_rec++ = *(buf_rec+i);
/*	printf("%d \n",*(buf_send+i));   */
      }
     }
    }
    return 0;
    }

static int xmit_boot(WDC_DEVICE_HANDLE hDev, int imod_xmit)
{
#include "wdc_defs.h"
#define  mb_xmit_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = buf_send;
      printf(" boot xmit module \n");
      inpf = fopen("/home/ub/xmit_fpga","r");
      imod=imod_xmit;
      ichip=mb_xmit_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
      usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
      fclose(inpf);
      return i;
}


    static int fem_boot(WDC_DEVICE_HANDLE hDev, int imod_fem)
{
#include "wdc_defs.h"
#define  mb_feb_conf_add 0x2

    FILE *inpf;
    int imod,ichip,count,counta,ichip_c,dummy1,ik,ij,i;
    unsigned char charchannel,carray[4000];
    int nsend,nword,k;
    UINT32 buf_send[10000],send_array[10000];
    UINT32 *px;
    struct timespec tim,tim2;
    tim.tv_sec=0;
    tim.tv_nsec = 128000;
//
//    boot up xmit module 1st
//
      nsend=500;
      px = buf_send;
//
//    Boot stratix after XMIT module
//
      inpf = fopen("/home/ub/feb_fpga_test","r");
      imod=imod_fem;
      ichip=mb_feb_conf_add;
      buf_send[0]=(imod<<11)+(ichip<<8)+0x0+(0x0<<16);  // turn conf to be on
      i=1;
      k=1;
      i = pcie_send(hDev, i, k, px);
//      for (i=0; i<100000; i++) {
//          ik= i%2;
//          dummy1= (ik+i)*(ik+i);
//      }


        /* read data as characters (28941) */
      usleep(1000);   // wait fior a while
      count = 0;
      counta= 0;
      ichip_c = 7; // set ichip_c to stay away from any other command in the
      dummy1 =0;
      while (fread(&charchannel,sizeof(char),1,inpf)==1) {
       carray[count] = charchannel;
       count++;
       counta++;
       if((count%(nsend*2)) == 0) {
//        printf(" loop = %d\n",dummy1);
        buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
        send_array[0] =buf_send[0];
        if(dummy1 <= 5 ) printf(" counta = %d, first word = %x, %x, %x %x %x \n",counta,buf_send[0], carray[0], carray[1]
        ,carray[2], carray[3]);
        for (ij=0; ij< nsend; ij++) {
         if(ij== (nsend-1)) buf_send[ij+1] = carray[2*ij+1]+(0x0<<16);
         else buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
//         buf_send[ij+1] = carray[2*ij+1]+ (carray[2*ij+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
        nword =nsend+1;
        i=1;
//       if(dummy1 == 0)
        ij = pcie_send(hDev, i, nword, px);
        nanosleep(&tim , &tim2);
        dummy1 = dummy1+1;
        count =0;
       }
      }
      if(feof(inpf)) {
       printf("You have reached the end-of-file word count= %d %d\n", counta, count);
       buf_send[0] = (imod <<11) +(ichip_c <<8)+ (carray[0]<<16);
       if ( count > 1) {
        if( ((count-1)%2) ==0) {
         ik =(count-1)/2;
        }
        else {
         ik =(count-1)/2+1;
        }
        ik=ik+2;   // add one more for safety
        printf("ik= %d\n",ik);
        for (ij=0; ij<ik; ij++){
         if(ij == (ik-1)) buf_send[ij+1] = carray[(2*ij)+1]+(((imod<<11)+(ichip<<8)+0x0)<<16);
         else buf_send[ij+1] = carray[(2*ij)+1]+ (carray[(2*ij)+2]<<16);
         send_array[ij+1] = buf_send[ij+1];
        }
       }
       else ik=1;

           for (ij=ik-10; ij< ik+1; ij++) {
            printf("Last data = %d, %x\n",ij,buf_send[ij]);
           }

       nword =ik+1;
       i=1;
       i = pcie_send(hDev, i, nword, px);
      }
       usleep(2000);    // wait for 2ms to cover the packet time plus fpga init time
       fclose(inpf);
      return i;
}

#endif



